<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> How is bidirectional information retrieved and generated in masked diffusion language models? | Ashish Rai </title> <meta name="author" content="Ashish Rai"> <meta name="description" content="Understanding Bidirectional Information Retrieval in MDLMs with ROME"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%A7%A0&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://raishish.github.io/blog/2025/discrete-diffusion-rome/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> <style type="text/css">.fake-img{background:#bbb;border:1px solid rgba(0,0,0,0.1);box-shadow:0 0 4px rgba(0,0,0,0.1);margin-bottom:12px}.fake-img p{font-family:monospace;color:white;text-align:left;margin:12px 0;text-align:center;font-size:16px}table{margin:1.5rem auto;border-collapse:collapse;width:100%}table caption{caption-side:top;text-align:center;font-weight:bold;margin-bottom:.5rem;color:var(--global-text-color)}table th,table td{border:1px solid var(--global-divider-color);padding:.5rem;text-align:left}table th{background-color:var(--global-bg-color-dark);font-weight:bold}.alert-info{color:#0c5460;background-color:#d1ecf1;border-color:#bee5eb;border:1px solid #bee5eb;border-left:4px solid #17a2b8;border-radius:.375rem;padding:1rem;margin:1rem 0}.alert-warning{color:#856404;background-color:#fff3cd;border-color:#ffeaa7;border:1px solid #ffeaa7;border-left:4px solid #ffc107;border-radius:.375rem;padding:1rem;margin:1rem 0}.alert-success{color:#155724;background-color:#d4edda;border-color:#c3e6cb;border:1px solid #c3e6cb;border-left:4px solid #28a745;border-radius:.375rem;padding:1rem;margin:1rem 0}</style> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "How is bidirectional information retrieved and generated in masked diffusion language models?",
            "description": "Understanding Bidirectional Information Retrieval in MDLMs with ROME",
            "published": "July 14, 2025",
            "authors": [
              
              {
                "author": "Ashish Rai",
                "authorURL": "https://raishish.github.io/",
                "affiliations": [
                  {
                    "name": "New York University",
                    "url": ""
                  }
                ]
              }
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Ashish</span> Rai </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">resumé </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>How is bidirectional information retrieved and generated in masked diffusion language models?</h1> <p>Understanding Bidirectional Information Retrieval in MDLMs with ROME</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#tl-dr">tl;dr</a> </div> <div> <a href="#abstract">Abstract</a> </div> <div> <a href="#introduction">Introduction</a> </div> <div> <a href="#background-and-related-work">Background and Related Work</a> </div> <div> <a href="#methodology">Methodology</a> </div> <ul> <li> <a href="#models">Models</a> </li> <li> <a href="#dataset">Dataset</a> </li> <li> <a href="#causal-tracing">Causal Tracing</a> </li> <li> <a href="#causal-tracing-for-diffusion-language-models">Causal Tracing for Diffusion Language Models</a> </li> </ul> <div> <a href="#current-progress">Current Progress</a> </div> <div> <a href="#future-work">Future Work</a> </div> <div> <a href="#acknowledgements">Acknowledgements</a> </div> <div> <a href="#references">References</a> </div> </nav> </d-contents> <h2 id="summary">Summary</h2> <h3 id="tldr">tl;dr</h3> <p>In this post, I will discuss the intermediate progress on using ROME to study bidirectional information retrieval in masked (discrete) diffusion language models.</p> <p>Analysis in-progress!</p> <h2 id="abstract">Abstract</h2> <p>This research proposal aims to conduct the first mechanistic investigation of bidirectional retrieval and generation in masked diffusion language models. We focus on masked diffusion models (MDMs), which have shown surprising resistance to the “reversal curse” that plagues autoregressive architectures. The study will map the causal pathways of knowledge recall and analyze the internal representations learned by the model. By leveraging recent insights into the “factorization curse” - a more fundamental problem underlying the reversal curse - we seek to understand how non-autoregressive architectures overcome these limitations. This mechanistic investigation will be among the first to systematically examine the internal workings of masked diffusion language models, providing insights into their emerging capabilities for bidirectional logical reasoning. The findings will contribute to the development of more robust language models with improved reasoning abilities and more reliable knowledge representation.</p> <h2 id="introduction">Introduction</h2> <p>Large language models (LLMs) have demonstrated impressive capabilities across diverse tasks, but recent studies have identified a significant limitation called the “reversal curse.” When autoregressive models like GPT learn a fact such as “A is B,” they fail to automatically deduce the reverse relationship “B is A” <d-cite key="berglund2023reversal"></d-cite>. For example, if a model learns that “Paris is the capital of France,” it struggles to answer “The capital of France is <em>__</em>” correctly.</p> <p>Recent work by <d-cite key="kitouni2024factorization"></d-cite> reframes this as the “factorization curse” - a more fundamental problem where language models fail to learn the same joint distribution under different factorizations. This insight suggests the issue isn’t just about reversing relationships, but about a broader limitation in how next-token prediction objectives force models to learn specific factorizations of joint distributions, undermining their ability to reason bidirectionally.</p> <p>Certain model architectures — particularly bidirectional encoder models like BERT and masked diffusion models (MDMs) — appear to be more resistant to this limitation (<d-cite key="wu2023exploring, nie2024scaling"></d-cite>). Understanding why these architectural differences lead to better bidirectional reasoning capabilities could provide valuable insights for developing more robust AI systems that overcome the factorization curse. This research proposal aims to investigate the mechanisms behind bidirectional information retrieval in language models, with a specific focus on masked diffusion models (MDMs).</p> <h2 id="background-and-related-work">Background and Related Work</h2> <p>The reversal curse was first formally identified in <d-cite key="berglund2023reversal"></d-cite>, which demonstrated that autoregressive models fine-tuned on statements like “A is B” failed to generalize to “B is A.” The authors showed that models like GPT-3 (175B) and Llama-1 (7B) scored no better than random chance when evaluated on reversed relationships.</p> <figure id="reversal-curse"> <img src="/assets/img/2025-discrete-diffusion-rome/reversal-curse.png" alt="The Reversal Curse"> <figcaption><strong>Figure 1:</strong> The Reversal Curse</figcaption> </figure> <p>Kitouni et al. (2024) significantly expanded the understanding of this phenomenon by reframing it as the “factorization curse” - a fundamental limitation of the next-token prediction objective used in most LLMs <d-cite key="kitouni2024factorization"></d-cite>. Through controlled experiments using their novel WikiReversal benchmark based on Wikipedia knowledge graphs, they demonstrated that this is an inherent failure mode that cannot be solved merely through scaling, reversed tokens, or even naive bidirectional-attention training. Their work identified factorization-agnostic objectives as a promising solution, showing significant improvements across various tasks of different complexity levels.</p> <p>Ma et al. (2023) investigated this problem specifically in the context of model editing, introducing the “Bidirectional Assessment for Knowledge Editing” (BAKE) benchmark and the “Bidirectionally Inversible Relationship moDeling” (BIRD) method <d-cite key="ma2023untying"></d-cite>. Their work revealed that while existing editing methods can effectively recall facts in the direction they were trained on, they perform poorly in the reverse direction. For instance, LLaMA-2 edited with state-of-the-art ROME could recall 99.70% of editing facts in the forward direction but only 0.26% in the reverse direction.</p> <p>Wu and Wang (2023) explored this phenomenon further, comparing autoregressive decoder-only models (like GPT) with bidirectional encoder models (like BERT) <d-cite key="wu2023exploring"></d-cite>. They found that BERT-style models were largely immune to the reversal curse for basic logical deductions, suggesting that architectural differences play a critical role.</p> <p>Recent advances in masked diffusion models have shown particularly promising results. Nie et al. (2024) demonstrated that a 1.1B parameter MDM could break the reversal curse that much larger autoregressive models struggle with <d-cite key="nie2024scaling"></d-cite>. Similarly, research on LLaDA (Large Language Diffusion Models) has shown that diffusion-based approaches effectively address bidirectional reasoning challenges and even outperform GPT-4o on certain reversal tasks <d-cite key="nie2025largelanguagediffusionmodels"></d-cite>.</p> <details> <summary><strong>A primer on masked discrete diffusion</strong></summary> </details> <h2 id="research-objectives">Research Objectives</h2> <p>This study aims to:</p> <ol> <li> <strong>Map the causal pathways of knowledge recall</strong> to understand how information flows when retrieving facts in forward versus reverse directions.</li> <li> <strong>Analyze learned representations</strong> to determine if and how they encode bidirectional logical relationships, identifying any symmetries in forward and backward representation of concepts.</li> </ol> <h2 id="methodology">Methodology</h2> <h3 id="models">Models</h3> <ul> <li>Masked Diffusion Language Model: <strong>SMDM-1028M</strong> - Llama2 based 1B masked diffusion model from <d-cite key="nie2024scaling"></d-cite> </li> <li>(Baseline) Autoregressive Models: <strong>AR-1028M</strong> - Llama2 based 1B autoregressive decoder only model from <d-cite key="nie2024scaling"></d-cite> </li> </ul> <table id="tab-model-config"> <caption> <strong>Table 1:</strong> Model configuration parameters used in experiments.</caption> <thead> <tr> <th>Model Type</th> <th>Masked Diffusion</th> <th>Autoregressive</th> </tr> </thead> <tbody> <tr> <td>Base Architecture</td> <td>Llama2</td> <td>Llama2</td> </tr> <tr> <td>Transformer Blocks</td> <td>20</td> <td>20</td> </tr> <tr> <td>Attention Heads</td> <td>14</td> <td>14</td> </tr> <tr> <td><code>n_embed</code></td> <td>1792</td> <td>1792</td> </tr> <tr> <td><code>embed_dim</code></td> <td>7168</td> <td>7168</td> </tr> <tr> <td><code>vocab_size</code></td> <td>32000</td> <td>32000</td> </tr> <tr> <td>Sampling temperature</td> <td>0.</td> <td>0.</td> </tr> <tr> <td>Sampling algorithm</td> <td>Greedy</td> <td>Greedy</td> </tr> </tbody> </table> <table id="smdm-sampling-config"> <caption> <strong>Table 2:</strong> Sampling configuration for SMDM-1028M (Masked Diffusion)</caption> <thead> <tr> <th>Config</th> <th>Value</th> </tr> </thead> <tbody> <tr> <td>Denoising Steps</td> <td>16</td> </tr> <tr> <td>Context Length</td> <td>52</td> </tr> <tr> <td>CFG Scale</td> <td>0.8</td> </tr> </tbody> </table> <p>The models chosen in this study are pre-trained on the SlimPajama Dataset <d-cite key="nie2024scaling"></d-cite>. These models are based on the Llama2 architecture and are configured with settings referenced in <a href="#tab-model-config">Table 1</a>. The sampling config for the masked diffusion language model SMDM-1028M has been borrowed from <d-cite key="nie2024scaling"></d-cite> as well and is shown in <a href="#smdm-sampling-config">Table 2</a>. The denoising steps indicate the number of steps over which the masked model response is unmasked. The context length refers to the total length of the sequence given as input to model, which includes both the prompt and the unmasked reponse <a href="#masked-diffusion-inference">Fig 2</a>. The CFG scale is the factor with which the classifier free guidance is scaled and applied for conditional generation.</p> <figure id="masked-diffusion-inference"> <img src="/assets/img/2025-discrete-diffusion-rome/masked_response.png" alt="Denoising response sequence during inference in masked diffusion language models"> <figcaption><strong>Figure 2:</strong> The prompt token is padded with masked tokens which are iteratively denoised during sampling from a masked diffusion language model.</figcaption> </figure> <h3 id="dataset">Dataset</h3> <p>The reversal curse can be studied with factual recall on:</p> <ul> <li>Completions based on pre-trained data</li> <li>Completions based on SFT-trained data</li> </ul> <p>The masked diffusion model was first prompted to generate single-token completions on Wikipedia knowledge prompts, which the model is trained on as part of SlimPajama. The last token did not elicit the most informative tokens. A subset of the responses can be seen in <a href="#wikipedia-knowledge-prompt-completions">Fig 3</a>.</p> <figure id="wikipedia-knowledge-prompt-completions"> <img src="/assets/img/2025-discrete-diffusion-rome/pre-training-single-token-completions.png" alt="Wikipedia Knowledge Prompt Completions"> <figcaption><strong>Figure 3:</strong> Generations by SMDM-1028M on Wikipedia knowledge prompts yields high entropy (less information in first generated token) and could not be used as a controlled database to test the reversal curse on.</figcaption> </figure> <p>The models were then fine tuned on the Reversal curse dataset and attained high accuracy <a href="#tab-reversal-curse-eval">Table 3</a>, so we chose this dataset. The samples from the dataset are depicted in <a href="#dataset">Fig. 4</a>.</p> <figure id="dataset"> <img src="/assets/img/2025-discrete-diffusion-rome/dataset.png" alt="Dataset"> <figcaption><strong>Figure 4:</strong> The reversal curse dataset.</figcaption> </figure> <h3 id="causal-tracing">Causal Tracing</h3> <p>\cite{Meng2022LocatingAE} introduced causal tracing as a method to identify storage and processing of factual knowledge in language models. The technique aims to isolate the causal effect of individual states within the network while processing factual statements, essentially mapping the information flow path through the model.</p> <p>The method aims to understand the model’s prediction, focusing on identifying key neurons and layers involved in recalling factual associations.</p> <h4 id="tracing-information-flow">Tracing Information Flow</h4> <d-cite key="Meng2022LocatingAE"></d-cite> <p>use causal mediation analysis to quantify the contribution of intermediate variables (hidden states) in the model’s causal graph to a correct factual prediction <d-cite key="10.5555/2074022.2074073, vig2020investigating"></d-cite>.</p> <p>To calculate each state’s contribution, they observe the model’s internal activations during three runs:</p> <ol> <li> <strong>Clean Run:</strong> A factual prompt $x$ is passed into the model $G$, and all hidden activations are collected.</li> <li> <strong>Corrupted Run:</strong> The subject $s$ is obfuscated from $G$ before the network runs to damage the prediction.</li> <li> <strong>Corrupted-with-Restoration Run:</strong> The model runs computations on the noisy embeddings as in the corrupted baseline, except at some token $i$ and layer $l$, the model is forced to output the clean state $h^{(l)}_i$.</li> </ol> <p><strong>Indirect Effect (IE):</strong> The indirect effect of a specific mediating state $h^{(l)}_i$ is defined as the difference between the probability of $o$ under the corrupted version and the probability when that state is set to its clean version, while the subject remains corrupted.</p> <p><strong>Average Indirect Effect (AIE):</strong> Averaging over a sample of statements, the average total effect (ATE) and average indirect effect (AIE) is obtained for each hidden state variable.</p> <h4 id="extracting-factual-representations">Extracting Factual Representations</h4> <p>Meng et al., 2022 <d-cite key="Meng2022LocatingAE"></d-cite> build upon the localized factual association hypothesis to devise a method to <strong>localize factual associations</strong> within transformer models. By locating the layer and weight matrix where a new fact can be injected with minimal interference, ROME provides evidence that factual knowledge is encoded in specific MLP projection layers as <strong>linear associations</strong> between key and value vectors. The proposed method by <d-cite key="Meng2022LocatingAE"></d-cite> is explained briefly for context.</p> <p><strong>Extracting the Key $k_{\ast}$</strong></p> <p>To identify the memory location corresponding to the subject $s$ in the factual triple $(s, r, o)$ a key vector $k_{\ast}$ is constructed with the underlying assumption being certain activations within the MLP are responsible for retrieving facts associated with a given subject. To find a robust key, the activation vectors are averaged across multiple short text prefixes that lead into and end with the subject token $s$.</p> \[k_{\ast} = \frac{1}{N} \sum_{j=1}^N k(x_j + s)\] <p>where $k(x)$ is derived from the layer $l^*$’s MLP activations after the non-linearity is applied.</p> <p><strong>Extracting the Value $v_{\ast}$</strong></p> <p>Meng et al., 2022 <d-cite key="Meng2022LocatingAE"></d-cite> compute a value vector $v_{\ast}$ that encodes a new object $o^*$ (i.e., the fact to be recalled) as a property of the subject $s$. This is formulated as an optimization problem with a linear combination of two objectives:</p> <ol> <li>Maximize the likelihood that the model, when prompted with subject $s$ and relation $r$, predicts the new object $o^*$.</li> <li>Minimize the KL divergence between the model’s original predictions for $s$ and its predictions after editing, to prevent disrupting the subject’s broader semantic identity.</li> </ol> <p>This results in the following loss objective:</p> \[\mathcal{L}(z) = - \frac{1}{N} \sum_{j=1}^N \log \mathbb{P}_{G(m_i^{(l^*)} := z)}(o^* \mid x_j + p) + D_{\mathrm{KL}}\left( \mathbb{P}_{G(m_{i'}^{(l^*)} := z)}[x \mid p'] \,\Vert\, \mathbb{P}_G[x \mid p'] \right)\] <p>where $z$ is optimized to serve as $v_{\ast}$, the value that, when output by the MLP, causes the model to recall the new object $o^*$ in response to the original factual prompt $p$. $p’$ represents the set of adjacent prompts (of the form “{subject} is a”) which aim to preserve the model’s understanding of the subject’s essence.</p> <p>In contrast, <strong>we aim to determine the representation of the original object $o$ when preceded with subject $s$ in the prompt</strong>. So we update the objective function to account for $o$ instead of $o^*$ and the rest remains the same:</p> \[\mathcal{L}(z) = - \frac{1}{N} \sum_{j=1}^N \log \mathbb{P}_{G(m_i^{(l^*)} := z)}(o \mid x_j + p) + D_{\mathrm{KL}}\left( \mathbb{P}_{G(m_{i'}^{(l^*)} := z)}[x \mid p'] \,\Vert\, \mathbb{P}_G[x \mid p'] \right)\] <p>Meng et al., 2022 <d-cite key="Meng2022LocatingAE"></d-cite> go a step further and apply a <strong>rank-one update</strong> to the projection matrix $W^{(l)}_{\text{proj}}$ of the MLP at layer $l^*$, in order to encode a new key–value pair into the model’s weights. This is beyond the scope of this research study.</p> <h4 id="causal-tracing-for-diffusion-language-models">Causal Tracing for Diffusion Language Models</h4> <p>Unlike autoregressive and masked language models, which predict all response tokens in a single forward pass; response generation in masked diffusion language models starts with a sequence of all masked tokens $x_1$ with fixed length $L$ (context length) is set and a mask predictor $f_\theta$ unmasks all tokens following a noise schedule $\alpha_t$ over $T$ denoising steps to generate the response $x_0$. Specifically, the masked diffusion model simulates a diffusion process from $t = 1$ (fully masked) to $t = 0$ (unmasked), predicting all masks simultaneously at each step with the possibility of flexible remasking strategies (<a href="#unmasking-during-inference">Fig. 5</a>).</p> <figure id="unmasking-during-inference"> <img src="/assets/img/2025-discrete-diffusion-rome/unmasking-during-inference.png" alt="Unmasking tokens via sampling during inference"> <figcaption><strong>Figure 5:</strong> RMasked diffusion models simulate a diffusion process from t = 1 (fully masked) to t = 0 (unmasked), predicting all masks simultaneously at each step with the possibility of flexible remasking strategies.</figcaption> </figure> <p>For masked diffusion language modeling, the individual response tokens (as seen in <a href="#masked-diffusion-generation">Fig. 6</a>) can be unmasked at different time steps.</p> <figure id="masked-diffusion-generation"> <img src="/assets/img/2025-discrete-diffusion-rome/masked-diffusion-generation.png" alt="Response generation from masked diffusion language models"> <figcaption><strong>Figure 6:</strong> Response generation from masked diffusion language model.</figcaption> </figure> <p>During training, Masked diffusion models (MDMs) are trained to increased the likelihood of the data distribution for different masking conditions. During inference, the tokens can be masked with different sampling strategies to determine the order in which the response tokens are predicted. In the context of causal information flow analysis, this introduces both challenges and opportunities:</p> <ul> <li> <strong>Challenge:</strong> This introduces multiple causal paths from a subject token across different denoising time steps.</li> <li> <strong>Opportunity:</strong> By quantifying the information flow in the first denoising time step, often the most important one, we can isolate the information flow from the subject tokens and the intermediate unmasked object tokens (which the model can attend to from the second time step).</li> </ul> <p>Causal tracing is run from time steps $t = t_1$ to $t = t_2$.</p> <p>When retrieving information from a language model, the process acts like a key-based value lookup with the subject $s$ acting as a <code class="language-plaintext highlighter-rouge">key</code> and the object acting as a <code class="language-plaintext highlighter-rouge">value</code> to be extracted. Following <d-cite key="Meng2022LocatingAE"></d-cite>, the key vectors in MLP layers corresponding to the last subject token in identified important MLP units (discovered by causal tracing) will be fixed and the objective function defined in equation 2 will be optimized to extract the representation of the object $o$.</p> <p>This procedure will be done while trying to elicit knowledge in both forward (sample prompt: “The trailblazer known as Daphne Barrington was once”) and reverse (sample prompt: “Immersed in the world of directing the virtual reality masterpiece, A Journey Through Time.”) directions. The key and value representations in these cases would be interchanged between both runs. For example, the key in prompt 1 “Daphne Barrington” would act as the value in prompt 2. The aim is to compare the key and value representations of the same concept via dimensionality reduction techniques (SVD and PCA) to see if there exists a symmetry in which the information is encoded in the diffusion model.</p> <h2 id="current-progress">Current Progress</h2> <p>We begin with a scaling experiment to study the impact of sampling steps on knowledge recall, measured with exact match accuracy <d-cite key="berglund2023reversal"></d-cite>. As the sampling steps are increased, there is an increase in knowledge recall in both forward and reverse directions (refer <a href="#tab-reversal-curse-eval">Table 3</a>).</p> <div class="alert alert-warning"> Please note that these accuracy values for <code>Description2Person</code> reverse and <code>Person2Description</code> reverse are different from the ones reported in <d-cite key="nie2024scaling"></d-cite>. *We believe this is an error in reporting of the values since reverse recall is harder to model for language models, majorly because the perplexity of the text in description is usually higher than the text in person names of the Reversal Curse dataset <d-cite key="berglund2023reversal"></d-cite>.* </div> <table id="tab-reversal-curse-eval"> <caption> <strong>Table 3:</strong> Scaling sampling steps leads to better knowledge recall performance in forward and reverse directions.</caption> <thead> <tr> <th rowspan="2">Sampling Steps</th> <th colspan="2">Description2Person</th> <th colspan="2">Person2Description</th> </tr> <tr> <th>Same (easy)</th> <th>Reverse (difficult)</th> <th>Same (difficult)</th> <th>Reverse (easy)</th> </tr> <tr> <th></th> <th>% Acc ↑</th> <th>% Acc ↑</th> <th>% Acc ↑</th> <th>% Acc ↑</th> </tr> </thead> <tbody> <tr> <td>1 step</td> <td>91.3</td> <td>0</td> <td>0</td> <td>40.3</td> </tr> <tr> <td>2 steps</td> <td>97</td> <td>0.7</td> <td>2.3</td> <td>79</td> </tr> <tr> <td>4 steps</td> <td>96.3</td> <td>17</td> <td>25</td> <td>87.7</td> </tr> <tr> <td>8 steps</td> <td>97.3</td> <td>27.3</td> <td>37.7</td> <td>87.3</td> </tr> <tr> <td>16 steps</td> <td><strong>98</strong></td> <td><strong>31</strong></td> <td>42</td> <td>88.3</td> </tr> <tr> <td>32 steps</td> <td>97.7</td> <td>29.7</td> <td><strong>43</strong></td> <td><strong>90</strong></td> </tr> </tbody> </table> <p>This is a work-in-progress. More results coming soon!</p> <p>The existing code for the study can be found at <a href="https://github.com/raishish/diffusion-interp" rel="external nofollow noopener" target="_blank">raishish/diffusion-interp</a>.</p> <h2 id="future-work">Future Work</h2> <h2 id="acknowledgements">Acknowledgements</h2> <h2 id="references">References</h2> <p>If you would like to cite this work, please use the following BibTeX entry:</p> <div class="language-bibtex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">@article</span><span class="p">{</span><span class="nl">rai2025discrete-diffusion-rome</span><span class="p">,</span>
  <span class="na">title</span><span class="p">=</span><span class="s">{How is information retrieved and generated in masked diffusion language models?}</span><span class="p">,</span>
  <span class="na">author</span><span class="p">=</span><span class="s">{Rai, Ashish}</span><span class="p">,</span>
  <span class="na">year</span><span class="p">=</span><span class="s">{2025}</span><span class="p">,</span>
  <span class="na">month</span><span class="p">=</span><span class="s">{July}</span><span class="p">,</span>
  <span class="na">url</span><span class="p">=</span><span class="s">{https://raishish.github.io/blog/2025/discrete-diffusion-rome/}</span>
<span class="p">}</span>
</code></pre></div></div> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/2025-07-14-discrete-diffusion-rome.bib"></d-bibliography> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Ashish Rai. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> </body> </html>